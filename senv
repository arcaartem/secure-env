#!/usr/bin/env bash
set -euo pipefail

# senv - Secure Environment File Manager
# Manages encrypted .env files using SOPS (backend-agnostic)

VERSION="2.0.0"
DEFAULT_SECRETS_DIR="$HOME/.local/share/senv"

# Global overrides (set via flags)
PROJECT_OVERRIDE=""
SECRETS_PATH_OVERRIDE=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

err() { echo -e "${RED}error:${NC} $*" >&2; }
warn() { echo -e "${YELLOW}warning:${NC} $*" >&2; }
info() { echo -e "${BLUE}info:${NC} $*"; }
success() { echo -e "${GREEN}success:${NC} $*"; }

# Check for required dependencies
# Usage: check_deps sops git
check_deps() {
    local missing=()
    for cmd in "$@"; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        err "Required dependencies not found: ${missing[*]}"
        echo "" >&2
        echo "Install instructions:" >&2
        for cmd in "${missing[@]}"; do
            case "$cmd" in
                gpg)
                    echo "  gpg:  brew install gnupg (macOS) or apt install gnupg (Ubuntu)" >&2
                    ;;
                sops)
                    echo "  sops: brew install sops (macOS) or see https://github.com/getsops/sops" >&2
                    ;;
                git)
                    echo "  git:  brew install git (macOS) or apt install git (Ubuntu)" >&2
                    ;;
                age)
                    echo "  age:  brew install age (macOS) or see https://github.com/FiloSottile/age" >&2
                    ;;
                *)
                    echo "  $cmd: please install $cmd" >&2
                    ;;
            esac
        done
        exit 1
    fi
}

# Get project name (flag > env var > current directory)
get_project_name() {
    if [[ -n "$PROJECT_OVERRIDE" ]]; then
        echo "$PROJECT_OVERRIDE"
    elif [[ -n "${SENV_PROJECT:-}" ]]; then
        echo "$SENV_PROJECT"
    else
        basename "$(pwd)"
    fi
}

# Get secrets path (flag > env var > default)
get_secrets_path() {
    if [[ -n "$SECRETS_PATH_OVERRIDE" ]]; then
        echo "$SECRETS_PATH_OVERRIDE"
    elif [[ -n "${SENV_SECRETS_PATH:-}" ]]; then
        echo "$SENV_SECRETS_PATH"
    else
        echo "$DEFAULT_SECRETS_DIR"
    fi
}

# Check if initialized (has .sops.yaml)
check_init() {
    local secrets_path
    secrets_path=$(get_secrets_path)
    if [[ ! -f "$secrets_path/.sops.yaml" ]]; then
        err "senv not initialized. Run 'senv init' first."
        exit 1
    fi
}

# Get encrypted file path for project/env
get_enc_path() {
    local project="$1"
    local env="$2"
    local secrets_path
    secrets_path=$(get_secrets_path)
    echo "$secrets_path/$project/${env}.env.enc"
}

# ============================================================================
# Commands
# ============================================================================

cmd_init() {
    check_deps sops git

    local secrets_path
    secrets_path=$(get_secrets_path)

    # Check for existing .sops.yaml
    if [[ -f "$secrets_path/.sops.yaml" ]]; then
        success "Using existing .sops.yaml at $secrets_path"

        # Ensure git repo and .gitignore exist
        mkdir -p "$secrets_path"
        if [[ ! -d "$secrets_path/.git" ]]; then
            git -C "$secrets_path" init -q
            info "Initialized git repository"
        fi

        if [[ ! -f "$secrets_path/.gitignore" ]]; then
            cat > "$secrets_path/.gitignore" <<EOF
# Never commit decrypted files
*.env
!*.env.enc
EOF
            info "Created .gitignore"
        fi

        success "Initialized senv"
        info "Secrets: $secrets_path"
        return 0
    fi

    # Create secrets directory
    mkdir -p "$secrets_path"

    # Prompt for backend
    echo "Select encryption backend:"
    echo "  1) age  - Modern, simple encryption (recommended)"
    echo "  2) pgp  - GPG/PGP encryption"
    echo ""
    read -rp "Backend [age/pgp]: " backend

    case "$backend" in
        age|1)
            setup_age_backend "$secrets_path"
            ;;
        pgp|2)
            setup_pgp_backend "$secrets_path"
            ;;
        *)
            err "Invalid backend. Choose 'age' or 'pgp'"
            exit 1
            ;;
    esac

    # Initialize git repo
    if [[ ! -d "$secrets_path/.git" ]]; then
        git -C "$secrets_path" init -q
    fi

    # Create .gitignore
    cat > "$secrets_path/.gitignore" <<EOF
# Never commit decrypted files
*.env
!*.env.enc
EOF

    success "Initialized senv"
    info "Secrets: $secrets_path"
}

setup_age_backend() {
    local secrets_path="$1"
    check_deps age

    local age_key_file="${SOPS_AGE_KEY_FILE:-$HOME/.config/sops/age/keys.txt}"
    local age_recipient=""

    # Check for existing key
    if [[ -f "$age_key_file" ]]; then
        age_recipient=$(grep "public key:" "$age_key_file" | head -1 | sed 's/.*: //')
        if [[ -n "$age_recipient" ]]; then
            info "Found existing age key: $age_recipient"
        fi
    fi

    # If no key found, offer to generate
    if [[ -z "$age_recipient" ]]; then
        echo "No age key found at $age_key_file"
        read -rp "Generate a new age key? [Y/n]: " generate
        if [[ "$generate" != [nN] ]]; then
            mkdir -p "$(dirname "$age_key_file")"
            age-keygen -o "$age_key_file" 2>&1
            age_recipient=$(grep "public key:" "$age_key_file" | sed 's/.*: //')
            success "Generated age key: $age_recipient"
            info "Private key saved to: $age_key_file"
        else
            err "Age key required. Generate one with: age-keygen -o $age_key_file"
            exit 1
        fi
    fi

    # Create .sops.yaml
    cat > "$secrets_path/.sops.yaml" <<EOF
creation_rules:
  - path_regex: .*\.env\.enc$
    age: $age_recipient
EOF

    success "Configured age backend"
}

setup_pgp_backend() {
    local secrets_path="$1"
    check_deps gpg

    # List available GPG keys
    echo "Available GPG keys:"
    gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep -E "^sec|^uid" || {
        err "No GPG keys found. Create one with: gpg --full-generate-key"
        exit 1
    }
    echo ""
    read -rp "Enter GPG key ID (long format): " gpg_key

    if [[ -z "$gpg_key" ]]; then
        err "GPG key ID required"
        exit 1
    fi

    # Validate GPG key exists
    if ! gpg --list-secret-keys "$gpg_key" &>/dev/null; then
        err "GPG key '$gpg_key' not found"
        exit 1
    fi

    # Create .sops.yaml
    cat > "$secrets_path/.sops.yaml" <<EOF
creation_rules:
  - path_regex: .*\.env\.enc$
    pgp: $gpg_key
EOF

    success "Configured PGP backend"
    info "GPG Key: $gpg_key"
}

cmd_use() {
    check_deps sops
    check_init
    local env="${1:-}"

    if [[ -z "$env" ]]; then
        err "Usage: senv use <environment>"
        echo "Available: $(cmd_list 2>/dev/null | tr '\n' ' ')"
        exit 1
    fi

    local project
    project=$(get_project_name)
    local enc_path
    enc_path=$(get_enc_path "$project" "$env")

    if [[ ! -f "$enc_path" ]]; then
        err "Environment '$env' not found for project '$project'"
        info "Create it with: senv edit $env"
        exit 1
    fi

    # Check for unsaved changes
    if [[ -f ".env" ]]; then
        local current_env
        current_env=$(head -1 .env 2>/dev/null | grep "^# senv:" | sed 's/^# senv: //' || echo "")
        if [[ -n "$current_env" && "$current_env" != "$env" ]]; then
            warn "Current .env is from '$current_env' environment"
        fi
    fi

    # Decrypt to .env
    local secrets_path
    secrets_path=$(get_secrets_path)
    local sops_config="$secrets_path/.sops.yaml"
    info "Decrypting $env → .env"
    {
        echo "# senv: $env"
        echo "# Decrypted from: $enc_path"
        echo "# Do not commit this file!"
        echo ""
        sops --config "$sops_config" --input-type dotenv --output-type dotenv -d "$enc_path"
    } > .env

    success "Activated '$env' environment for '$project'"

    # Check for .envrc
    if [[ ! -f ".envrc" ]]; then
        info "Tip: Create .envrc with 'dotenv' for auto-loading"
    fi
}

cmd_edit() {
    check_deps sops
    check_init
    local env="${1:-}"

    if [[ -z "$env" ]]; then
        err "Usage: senv edit <environment>"
        exit 1
    fi

    local project
    project=$(get_project_name)
    local secrets_path
    secrets_path=$(get_secrets_path)
    local enc_path
    enc_path=$(get_enc_path "$project" "$env")
    local project_dir="$secrets_path/$project"
    local sops_config="$secrets_path/.sops.yaml"

    # Create project directory if needed
    mkdir -p "$project_dir"

    # Create new file or edit existing
    if [[ ! -f "$enc_path" ]]; then
        info "Creating new environment: $env"
        # Create minimal encrypted file using .sops.yaml rules
        # Use --filename-override so path_regex in .sops.yaml matches the output file
        echo "# Add your environment variables below" | \
            sops --config "$sops_config" --filename-override "$enc_path" -e --input-type dotenv --output-type dotenv /dev/stdin > "$enc_path"
    fi

    # Open in editor via SOPS
    sops --config "$sops_config" --input-type dotenv --output-type dotenv "$enc_path"
    success "Saved $env environment"
}

cmd_save() {
    check_deps sops
    check_init

    if [[ ! -f ".env" ]]; then
        err "No .env file in current directory"
        exit 1
    fi

    # Get environment from header
    local env
    env=$(head -1 .env 2>/dev/null | grep "^# senv:" | sed 's/^# senv: //' || echo "")

    if [[ -z "$env" ]]; then
        err ".env was not created by senv (missing header)"
        info "Use 'senv edit <env>' to create a new environment"
        exit 1
    fi

    local project
    project=$(get_project_name)
    local secrets_path
    secrets_path=$(get_secrets_path)
    local enc_path
    enc_path=$(get_enc_path "$project" "$env")
    local sops_config="$secrets_path/.sops.yaml"

    # Create backup
    if [[ -f "$enc_path" ]]; then
        cp "$enc_path" "${enc_path}.backup"
    fi

    # Strip senv header comments and encrypt using .sops.yaml rules
    # Use --filename-override so path_regex in .sops.yaml matches the output file
    info "Encrypting .env → $env"
    grep -v "^# senv:" .env | grep -v "^# Decrypted from:" | grep -v "^# Do not commit" | \
        sops --config "$sops_config" --filename-override "$enc_path" -e --input-type dotenv --output-type dotenv /dev/stdin > "$enc_path"

    success "Saved to $enc_path"
    info "Don't forget to commit changes in $secrets_path"
}

cmd_list() {
    check_init
    local project
    project=$(get_project_name)
    local secrets_path
    secrets_path=$(get_secrets_path)
    local project_dir="$secrets_path/$project"

    if [[ ! -d "$project_dir" ]]; then
        err "No environments for project '$project'"
        info "Create one with: senv edit <environment>"
        exit 1
    fi

    # List .env.enc files
    for f in "$project_dir"/*.env.enc; do
        [[ -f "$f" ]] || continue
        basename "$f" .env.enc
    done
}

cmd_diff() {
    check_deps sops
    check_init
    local env="${1:-}"

    if [[ -z "$env" ]]; then
        # Try to get from current .env header
        env=$(head -1 .env 2>/dev/null | grep "^# senv:" | sed 's/^# senv: //' || echo "")
        if [[ -z "$env" ]]; then
            err "Usage: senv diff <environment>"
            exit 1
        fi
    fi

    if [[ ! -f ".env" ]]; then
        err "No .env file in current directory"
        exit 1
    fi

    local project
    project=$(get_project_name)
    local enc_path
    enc_path=$(get_enc_path "$project" "$env")

    if [[ ! -f "$enc_path" ]]; then
        err "Environment '$env' not found"
        exit 1
    fi

    # Diff current .env (stripped of headers) vs decrypted stored version
    local secrets_path
    secrets_path=$(get_secrets_path)
    local sops_config="$secrets_path/.sops.yaml"
    local current_clean
    current_clean=$(grep -v "^# senv:" .env | grep -v "^# Decrypted from:" | grep -v "^# Do not commit")

    local stored
    stored=$(sops --config "$sops_config" --input-type dotenv --output-type dotenv -d "$enc_path")

    diff -u --label "stored ($env)" --label "local (.env)" <(echo "$stored") <(echo "$current_clean") || true
}

cmd_status() {
    check_init
    local project
    project=$(get_project_name)

    echo "Project: $project"

    if [[ -f ".env" ]]; then
        local env
        env=$(head -1 .env 2>/dev/null | grep "^# senv:" | sed 's/^# senv: //' || echo "unknown")
        echo "Active: $env"
    else
        echo "Active: (none)"
    fi

    echo "Available:"
    cmd_list 2>/dev/null | sed 's/^/  - /' || echo "  (none)"
}

cmd_delete() {
    check_init
    local env="${1:-}"

    if [[ -z "$env" ]]; then
        err "Usage: senv delete <environment>"
        exit 1
    fi

    local project
    project=$(get_project_name)
    local enc_path
    enc_path=$(get_enc_path "$project" "$env")

    if [[ ! -f "$enc_path" ]]; then
        err "Environment '$env' not found for project '$project'"
        exit 1
    fi

    warn "This will permanently delete the '$env' environment for '$project'"
    read -rp "Are you sure? [y/N] " confirm
    [[ "$confirm" != [yY] ]] && exit 0

    rm -f "$enc_path"
    rm -f "${enc_path}.backup"
    success "Deleted '$env' environment"

    # Clean up empty project directory
    local secrets_path
    secrets_path=$(get_secrets_path)
    local project_dir="$secrets_path/$project"
    if [[ -d "$project_dir" ]] && [[ -z "$(ls -A "$project_dir")" ]]; then
        rmdir "$project_dir"
        info "Removed empty project directory"
    fi
}

cmd_export() {
    check_deps sops
    check_init
    local output_dir="."
    local force=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output-dir)
                output_dir="$2"
                shift 2
                ;;
            --force)
                force=true
                shift
                ;;
            *)
                err "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    local project
    project=$(get_project_name)
    local secrets_path
    secrets_path=$(get_secrets_path)
    local project_dir="$secrets_path/$project"
    local sops_config="$secrets_path/.sops.yaml"

    # Check project has environments
    if [[ ! -d "$project_dir" ]]; then
        warn "No environments for project '$project'"
        exit 0
    fi

    # Collect environments
    local envs=()
    for f in "$project_dir"/*.env.enc; do
        [[ -f "$f" ]] || continue
        envs+=("$(basename "$f" .env.enc)")
    done

    if [[ ${#envs[@]} -eq 0 ]]; then
        warn "No environments found for project '$project'"
        exit 0
    fi

    # Ensure output directory exists
    if [[ ! -d "$output_dir" ]]; then
        err "Output directory does not exist: $output_dir"
        exit 1
    fi

    # Pre-check: verify no conflicts (unless --force)
    if [[ "$force" != true ]]; then
        local conflicts=()
        for env in "${envs[@]}"; do
            local target="$output_dir/.env.$env"
            if [[ -f "$target" ]]; then
                conflicts+=("$target")
            fi
        done

        if [[ ${#conflicts[@]} -gt 0 ]]; then
            err "Target files already exist:"
            for c in "${conflicts[@]}"; do
                echo "  - $c" >&2
            done
            info "Use --force to overwrite"
            exit 1
        fi
    fi

    # Export all environments
    info "Exporting ${#envs[@]} environment(s) for '$project'"
    for env in "${envs[@]}"; do
        local enc_path
        enc_path=$(get_enc_path "$project" "$env")
        local target="$output_dir/.env.$env"

        sops --config "$sops_config" --input-type dotenv --output-type dotenv -d "$enc_path" > "$target"
        success "Exported: $target"
    done

    success "Exported ${#envs[@]} environment(s) to $output_dir"
}

cmd_import() {
    check_deps sops
    check_init
    local force=false
    local keep=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=true
                shift
                ;;
            --keep)
                keep=true
                shift
                ;;
            *)
                err "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    local project
    project=$(get_project_name)
    local secrets_path
    secrets_path=$(get_secrets_path)
    local project_dir="$secrets_path/$project"
    local sops_config="$secrets_path/.sops.yaml"

    # Discover .env.<suffix> files (single suffix only)
    local files=()
    local envs=()
    for f in .env.*; do
        [[ -f "$f" ]] || continue
        # Skip .env.enc, .env.backup, and multi-suffix files
        local basename="${f#.env.}"
        # Skip if basename contains a dot (multi-suffix)
        [[ "$basename" == *"."* ]] && continue
        # Skip known extensions
        [[ "$basename" == "enc" || "$basename" == "backup" ]] && continue
        files+=("$f")
        envs+=("$basename")
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        warn "No .env.<environment> files found to import"
        exit 0
    fi

    # Pre-check: verify no conflicts in repo (unless --force)
    if [[ "$force" != true ]]; then
        local conflicts=()
        for env in "${envs[@]}"; do
            local enc_path
            enc_path=$(get_enc_path "$project" "$env")
            if [[ -f "$enc_path" ]]; then
                conflicts+=("$env")
            fi
        done

        if [[ ${#conflicts[@]} -gt 0 ]]; then
            err "Environments already exist in secrets repo:"
            for c in "${conflicts[@]}"; do
                echo "  - $c" >&2
            done
            info "Use --force to overwrite"
            exit 1
        fi
    fi

    # Create project directory if needed
    mkdir -p "$project_dir"

    # Import all files
    info "Importing ${#files[@]} environment(s) for '$project'"
    for i in "${!files[@]}"; do
        local file="${files[$i]}"
        local env="${envs[$i]}"
        local enc_path
        enc_path=$(get_enc_path "$project" "$env")

        # Encrypt using .sops.yaml rules
        # Use --filename-override so path_regex in .sops.yaml matches the output file
        sops --config "$sops_config" --filename-override "$enc_path" -e --input-type dotenv --output-type dotenv "$file" > "$enc_path"
        success "Imported: $file → $env"

        # Delete source file unless --keep
        if [[ "$keep" != true ]]; then
            rm -f "$file"
        fi
    done

    success "Imported ${#files[@]} environment(s)"
    if [[ "$keep" != true ]]; then
        info "Source files deleted"
    else
        info "Source files preserved (--keep)"
    fi
    info "Don't forget to commit changes in $secrets_path"
}

cmd_repo() {
    check_init
    local secrets_path
    secrets_path=$(get_secrets_path)
    echo "$secrets_path"
    info "Run: cd \"\$(senv repo)\" to change directory"
}

cmd_help() {
    local secrets_path
    secrets_path=$(get_secrets_path)
    cat <<EOF
senv $VERSION - Secure Environment File Manager

USAGE:
    senv [-p <project>] [-s <path>] <command> [args]

OPTIONS:
    -p, --project <name>       Use specified project instead of current directory name
    -s, --secrets-path <path>  Use specified secrets repo path

ENVIRONMENT VARIABLES:
    SENV_PROJECT       Override project name (lower priority than -p flag)
    SENV_SECRETS_PATH  Override secrets repo path (lower priority than -s flag)
                       Default: ~/.local/share/senv

COMMANDS:
    init            Initialize senv (interactive backend selection)
    use <env>       Decrypt environment and write .env
    edit <env>      Edit encrypted environment file
    save            Encrypt current .env back to secrets repo
    list            List available environments for current project
    diff [env]      Show diff between local .env and stored version
    delete <env>    Delete an environment permanently
    status          Show current project status
    repo            Print secrets repo path (use: cd "\$(senv repo)")
    export          Export all environments as .env.<env> files
    import          Import all .env.<env> files into secrets repo
    help            Show this help message

EXPORT OPTIONS:
    --output-dir <path>  Export to specified directory (default: current)
    --force              Overwrite existing files

IMPORT OPTIONS:
    --force              Overwrite existing environments in repo
    --keep               Keep source .env files after import (default: delete)

SUPPORTED BACKENDS:
    age             Modern encryption (recommended) - https://github.com/FiloSottile/age
    pgp             GPG/PGP encryption

EXAMPLES:
    senv init                 # First-time setup (choose backend)
    senv edit local           # Create/edit local environment
    senv use local            # Activate local environment
    senv save                 # Save changes back
    senv use staging          # Switch to staging
    senv export               # Export all envs as .env.* files
    senv import               # Import all .env.* files

CONFIGURATION:
    Secrets: $secrets_path
    SOPS config: $secrets_path/.sops.yaml
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--project)
                PROJECT_OVERRIDE="$2"
                shift 2
                ;;
            -s|--secrets-path)
                SECRETS_PATH_OVERRIDE="$2"
                shift 2
                ;;
            -*)
                # Check if it's a help/version flag
                case "$1" in
                    -h|--help) cmd_help; exit 0 ;;
                    -v|--version) echo "senv $VERSION"; exit 0 ;;
                    *)
                        err "Unknown option: $1"
                        exit 1
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
    done

    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init)   cmd_init "$@" ;;
        use)    cmd_use "$@" ;;
        edit)   cmd_edit "$@" ;;
        save)   cmd_save "$@" ;;
        list)   cmd_list "$@" ;;
        diff)   cmd_diff "$@" ;;
        delete|rm) cmd_delete "$@" ;;
        status) cmd_status "$@" ;;
        repo|cd) cmd_repo "$@" ;;
        export) cmd_export "$@" ;;
        import) cmd_import "$@" ;;
        help|--help|-h) cmd_help ;;
        version|--version|-v) echo "senv $VERSION" ;;
        *)
            err "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
